# TITLE: ADEX summary generator
# DESCRIPTION: grub required information generated by ADEX
# AUTHOR: zhangh15@myumanitoba.com

import logging as lg
import os
import time
#import myUtils.ConfigParser as mParser
import ConfigParser as mParser
#from myUtils.database import Database
from database import Database


HEAD_NAME_LIST = [['File_Name'          ,'TEXT'],
                  ['Number_Recordings'  ,'INT'],
                  ['File_Hours'         ,'REAL'],
                  ['Child_ChildID'      ,'TEXT'],
                  ['Child_Age'          ,'INT'],
                  ['Child_Gender'       ,'TEXT'],
                  ['AWC'                ,'INT'],
                  ['Turn_Count'         ,'INT'],
                  ['Child_Voc_Count'    ,'INT'],
                  ['CHN'                ,'REAL'],
                  ['Child_Voc_Duration' ,'INT'],
                  ['FAN_Word_Count'     ,'INT'],
                  ['FAN'                ,'REAL'],
                  ['MAN_Word_Count'     ,'INT'],
                  ['MAN'                ,'REAL'],
                  ['CXN'                ,'REAL'],
                  ['OLN'                ,'REAL'],
                  ['TVN'                ,'REAL'],
                  ['NON'                ,'REAL'],
                  ['SIL'                ,'REAL'],
                  ['Clock_Time_TZAdj'   ,'TEXT'],
                  ['Audio_Duration'     ,'REAL']]

HEAD_TYPE_DICT = dict(HEAD_NAME_LIST)


class ADEXProcessor:
    def __init__(self):
        self.no_naptime = False
        self.no_30mins = False
        self.no_partial = False
        self.no_last2rows = False
        self.naptime_dict = {}
        self.child = {}
        self.time_interval = "5 minutes"
        self.switches = [['AWC', True],
                         ['Turn_Count', True],
                         ['Child_Voc_Count', True],
                         ['CHN', True],
                         ['FAN', True],
                         ['MAN', True],
                         ['CXN', True],
                         ['OLN', True],
                         ['TVN', True],
                         ['NON', True],
                         ['SIL', True]]

    # [Todo] change switches to item name only
    def set_switches(self, switches):
        for i, item in enumerate(switches):
            self.switches[i][1] != item
            self.switches[i][1] = item

        self.item_list = [x[0] for x in self.switches if x[1] is True]
        self.summary = [['ID', 'Age', 'Gender'] + self.item_list]

    def read_naptime(self, DB):
        naptime_db = Database(DB)
        naptime_list = naptime_db.select('naptime', ['child_cd', 'start', 'end'])
        naptime_db.close()

        for entry in naptime_list:
            child_id = entry[0].split('_')[0].lower()
            date = entry[0].split('_')[1]
            if child_id not in self.naptime_dict:
                self.naptime_dict[child_id] = [(date, entry[1], entry[2])]
            else:
                self.naptime_dict[child_id].append((date, entry[1], entry[2]))

    def get_average(self, DB):
        id_list = DB.select('sqlite_sequence', ['name'], order_by='name ASC')
        id_list = [x[0] for x in id_list]
        avg_param = ['AVG(' + x + ')' for x in self.item_list]

        # generate average values for each ID (all files)
        for child_id in id_list:
            count = len(DB.select(child_id, ['File_Name'], distinct=True, order_by='File_Name ASC'))
            result = list(DB.select(child_id, avg_param)[0])

            # format to show only two digits
            for i in range(len(result)):
                result[i] = "{:.2f}".format(result[i])

            self.summary.append([child_id + str(count) + self.time_interval,
                                 self.child[child_id][0],
                                 self.child[child_id][1]] + result)

    def run(self, dir_list, result_file):
        if self.no_naptime:
            self.read_naptime("/home/zhangh15/Dev/bll_app/test/bll_db.db")

        result_dir = os.path.dirname(result_file) + "/report"
        if not os.path.exists(result_dir):
            os.mkdir(result_dir)

        for path in dir_list:
            basename = os.path.basename(path)
            os.chdir(path)
            current_DB = Database(basename+'.sqlite3')
            file_list = os.listdir(path)

            for ADEX_file in file_list:
                if not ADEX_file.endswith(".csv"):
                    continue

                mADEX = ADEXFileProcessor(path + '/' + ADEX_file)
                if mADEX.child_id not in self.child:
                    self.child[mADEX.child_id] = [mADEX.get_ChildAge(),
                                                  mADEX.get_ChildGender()]

                if self.no_30mins:
                    mADEX.remove_30mins()

                # remove last 2 rows before nap time and partial
                if self.no_last2rows:
                    mADEX.remove_last2rows()

                if self.no_naptime:
                    mADEX.remove_naptime(self.naptime_dict)

                if self.no_partial:
                    interval_sec = int(self.time_interval.split()[0]) * 60
                    mADEX.remove_partial_time(interval_sec)

                mADEX.save_DB(current_DB)

            self.save_middle_results(current_DB, result_dir + "/preliminary.xlsx")
            self.get_average(current_DB)

            current_DB.close()
            os.remove(basename + ".sqlite3")

        self.save_results(result_file)

    # preliminary results for references
    def save_middle_results(self, DB, filename):
        id_list = DB.select('sqlite_sequence', ['name'], order_by='name ASC')
        id_list = [x[0] for x in id_list]
        head_list = [x[0] for x in HEAD_NAME_LIST]
        head_list.insert(0, "Index")

        for child_id in id_list:
            result = DB.select(child_id, '*', order_by='File_Name ASC')
            result.insert(0, head_list)
            mParser.excel_writer(filename, child_id, result)

    def save_results(self, filename):
        mParser.excel_writer(filename, 'ADEX_OUTPUT', self.summary)

    def get_config(self):
        config_dict = {}

        config_dict['enable'] = True
        config_dict['time_interval'] = self.time_interval
        config_dict['no_30mins'] = self.no_30mins
        config_dict['no_naptime'] = self.no_naptime
        config_dict['no_partial'] = self.no_partial
        config_dict['no_last2rows'] = self.no_last2rows
        config_dict['switches'] = self.switches

        return config_dict

# read ADEX csv files with required columns only
# then save these columns to DB
class ADEXFileProcessor:
    def __init__(self, ADEX_file):
        lg.debug(ADEX_file)
        self.heads = [x[0] for x in HEAD_NAME_LIST]
        self.content = mParser.csv_dict_reader(ADEX_file, self.heads)
        self.child_id = self.get_ChildID()
        self.start_time  = self.get_start_time()

    def remove_30mins(self):
        final_start = 0
        counter = 0
        index = self.heads.index('Audio_Duration')

        # remove first 1800 sec at the beginning
        for row in self.content:
            value = float(row[index])
            counter += value
            final_start += 1
            if counter >= 1800:
                break

        # remove 1800 sec at the end
        # final_end = len(self.content) - 1
        # counter = 0
        # for x in range(1, len(self.content)):
        #     value = float(self.content[-x][index])
        #     counter += value
        #     final_end -= 1
        #     if counter >= 1800:
        #         break

        # items start through final_end

        lg.debug("removing 5 minutes...")
        self.content = self.content[final_start:]

    def remove_last2rows(self):
        final_end = len(self.content) - 2
        if final_end > 0:
            self.content = self.content[:final_end]

    # find any time duration not up to the time interval
    def remove_partial_time(self, interval_sec):
        index = self.heads.index('Audio_Duration')
        clock_index = self.heads.index('Clock_Time_TZAdj')
        start_time = 0
        end_time = 0

        for row in self.content:
            value = float(row[index])
            if value != interval_sec:
                if start_time == 0:
                    start_time = self.timestr_to_second(row[clock_index]) - interval_sec
                end_time = self.timestr_to_second(row[clock_index]) + interval_sec
            else:
                if start_time != 0:
                    self.remove_time(start_time, end_time)
                    start_time = 0

            # for the last row
            if start_time != 0:
                self.remove_time(start_time, end_time)

    def get_ChildID(self):
        index = self.heads.index('Child_ChildID')
        return self.content[0][index].lower()

    def get_ChildAge(self):
        index = self.heads.index('Child_Age')
        return self.content[0][index].lower()

    def get_ChildGender(self):
        index = self.heads.index('Child_Gender')
        return self.content[0][index].lower()

    def get_start_time(self):
        index = self.heads.index('Clock_Time_TZAdj')
        return self.timestr_to_second(self.content[0][index])

    # convert time string to seconds
    def timestr_to_second(self, string):
        # string = 6/10/2009 8:37:45
        return time.mktime(time.strptime(string, '%m/%d/%Y %H:%M:%S'))

    # convert seconds to human readable string
    def second_to_timestr(self, second):
        return time.ctime(second)

    def remove_naptime(self, naptime_dict):
        if self.child_id in naptime_dict:
            start_date = time.strftime('%Y%m%d', time.localtime(self.start_time))
            for i in naptime_dict[self.child_id]:
                if i[0] == start_date:
                    self.remove_time(self.start_time + i[1],
                                     self.start_time + i[2])

    def remove_time(self, start_time, end_time):
        lg.debug("removing naptime...")
        time_start = 0
        time_end = len(self.content)
        count = 0
        index = self.heads.index('Clock_Time_TZAdj')

        for row in self.content:
            cur_time = self.timestr_to_second(row[index])

            if (cur_time >= start_time) and (time_start == 0):
                time_start = count
            if (cur_time > end_time) and (time_end == len(self.content)):

                time_end = count

            count += 1

        del self.content[time_start : time_end]

    def save_DB(self, DB):
        sql = ""
        # check the existence of childID
        if DB.select('sqlite_master', ['name'],
                     where="type='table' AND name='"+self.child_id +"'") is None:
            lg.debug(self.child_id + " is not in database")
            param = [i + ' ' + HEAD_TYPE_DICT[i] for i in self.heads]
            param.insert(0, "ID INTEGER PRIMARY KEY AUTOINCREMENT")
            param = ",".join(param)
            sql = "CREATE TABLE " + self.child_id + "(" + param + ")"
            DB.execute_script(sql)

        # insert content into DB
        DB.insert_table(self.child_id, self.heads, self.content)

# for test
if os.path.exists("/home/hao/Develop/projects/bll/bll_app/test/sample/output.xlsx"):
    os.remove("/home/hao/Develop/projects/bll/bll_app/test/sample/output.xlsx")

ADEX_proc = ADEXProcessor()
ADEX_proc.set_switches([True]*11)
ADEX_proc.no_30mins = True
ADEX_proc.no_last2rows = True
ADEX_proc.no_partial = True
ADEX_proc.run(["/home/hao/Develop/projects/bll/bll_app/test/sample"],
              "/home/hao/Develop/projects/bll/bll_app/test/sample/output.xlsx")
