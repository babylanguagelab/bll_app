# TITLE: ADEX summary generator
# DESCRIPTION: grub required information generated by ADEX
# AUTHOR: zhangh15@myumanitoba.com
# DATA: 2015/11/17

import logging as lg
import os
import time
import ConfigParser as mParser
from database import Database

HEAD_NAME_LIST = [['File_Name'          ,'TEXT'],
                  ['Number_Recordings'  ,'INT'],
                  ['File_Hours'         ,'REAL'],
                  ['Child_ChildID'      ,'TEXT'],
                  ['Child_Age'          ,'INT'],
                  ['Child_Gender'       ,'TEXT'],
                  ['AWC'                ,'INT'],
                  ['Turn_Count'         ,'INT'],
                  ['Child_Voc_Count'    ,'INT'],
                  ['CHN'                ,'REAL'],
                  ['Child_Voc_Duration' ,'INT'],
                  ['FAN_Word_Count'     ,'INT'],
                  ['FAN'                ,'REAL'],
                  ['MAN_Word_Count'     ,'INT'],
                  ['MAN'                ,'REAL'],
                  ['CXN'                ,'REAL'],
                  ['OLN'                ,'REAL'],
                  ['TVN'                ,'REAL'],
                  ['NON'                ,'REAL'],
                  ['SIL'                ,'REAL'],
                  ['Clock_Time_TZAdj'   ,'TEXT'],
                  ['Audio_Duration'     ,'REAL']]

HEAD_TYPE_DICT = dict(HEAD_NAME_LIST)

# convert time string to seconds
def timestr_to_second(string):
    # string = 6/10/2009 8:37:45
    return time.mktime(time.strptime(string, '%m/%d/%Y %H:%M:%S'))

# convert seconds to human readable string
def second_to_timestr(second):
    return time.ctime(second)


class ADEXProcessor:
    def __init__(self, database):
        self.config = {'f30mins' : True,
                       'partial_records' : False,
                       'naptime' : True,
                       'last2rows' : True,
                       'time_interval': 600, # seconds
                       'adex_dirs' : [],
                       'DB': database}
        self.naptime = ("/tmp/test/bll_db.db", {})
        self.child = {}
        self.switches = [['AWC', True], ['Turn_Count', True], ['Child_Voc_Count', True],
                         ['CHN', True], ['FAN', True], ['MAN', True], ['CXN', True],
                         ['OLN', True], ['TVN', True], ['NON', True], ['SIL', True]]

        item_list = [x[0] for x in self.switches if x[1] is True]
        self.output = (['ChildID', 'Age', 'Gender', 'Recordings'] + item_list, [])

    def set_switches(self, switches):
        for i, item in enumerate(switches):
            self.switches[i][1] = item

        item_list = [x[0] for x in self.switches if x[1] is True]
        self.output[0] = ['ChildID', 'Age', 'Gender', 'Recordings'] + item_list

    def read_naptime(self):
        naptime_db = Database(self.naptime[0])
        naptime_list = naptime_db.select('naptime', ['child_cd', 'start', 'end'])
        naptime_db.close()

        for entry in naptime_list:
            child_id = entry[0].split('_')[0].lower()
            date = entry[0].split('_')[1]

            if child_id not in self.naptime[1][child_id]:
                self.naptime[1][child_id] = [(date, entry[1], entry[2])]
            else:
                self.naptime[1][child_id] += [(date, entry[1], entry[2])]

    def get_average(self):
        childID_list = self.config['DB'].select('sqlite_sequence', ['name'], order_by='name ASC')
        childID_list = [x[0] for x in childID_list]
        item_list = [x[0] for x in self.switches if x[1] is True]

        avg_param = ['AVG(' + x + ')' for x in item_list]

        # generate average values for each ID (all files)
        for child_id in childID_list:
            result = list(self.config['DB'].select(child_id, avg_param)[0])
            tmp = self.child[child_id]
            result  = [child_id] + [x for x in tmp] + result
            self.config['DB'].insert("adex_summary", self.output[0], result)

            # format to show only two digits
            # for i in range(len(result)):
            #     result[i] = "{:.2f}".format(result[i])

            # self.summary.append([child_id + self.time_interval,
            #                      self.child[child_id][0],
            #                      self.child[child_id][1]] + result)

    # preliminary results for references
    def save_middle_results(self, DB):
        id_list = DB.select('sqlite_sequence', ['name'], order_by='name ASC')
        id_list = [x[0] for x in id_list]
        head_list = [x[0] for x in HEAD_NAME_LIST]
        head_list.insert(0, "Index")

        for child_id in id_list:
            result = DB.select(child_id, '*', order_by='File_Name ASC')
            result.insert(0, head_list)
            #mParser.excel_writer(filename, child_id, result)

    def run(self):
        if self.config['naptime']:
            self.read_naptime()

        # result_dir = os.path.dirname(result_file) + "/report"
        # if not os.path.exists(result_dir):
        #     os.mkdir(result_dir)

        if self.config['DB'].select('sqlite_master', ['name'],
                             where="type='table' AND name='adex_summary'") is None:

            param = self.output[0]
            #param.insert(0, "ID INTEGER PRIMARY KEY AUTOINCREMENT")
            param = ",".join(param)
            sql = "CREATE TABLE adex_summary" + "(" + param + ",PRIMARY KEY (ChildID)" + ")"
            self.config['DB'].execute_script(sql)

        for path in self.config['adex_dirs']:
            file_list = os.listdir(path)

            for ADEX_file in file_list:
                if not ADEX_file.endswith(".csv"):
                    continue

                mADEX = ADEXFileProcessor(path + '/' + ADEX_file)
                if mADEX.child_id not in self.child:
                    self.child[mADEX.child_id] = (mADEX.get_ChildAge(),
                                                  mADEX.get_ChildGender(),
                                                  mADEX.get_NumRecording())

                if self.config['f30mins']:
                    mADEX.remove_30mins()

                if self.config['naptime']:
                    mADEX.remove_naptime(self.naptime[1])

                if self.config['partial_records']:
                    interval_sec = int(self.config['time_interval'])
                    mADEX.remove_partial_time(interval_sec)

                if self.config['last2rows']:
                    mADEX.remove_last2rows()

                mADEX.save_DB(self.config['DB'])

            # self.save_middle_results(current_DB)
            self.get_average()


# read ADEX csv files with required columns only
# then save these columns to DB
class ADEXFileProcessor:
    def __init__(self, ADEX_file):
        lg.debug(ADEX_file)
        self.heads = [x[0] for x in HEAD_NAME_LIST]
        self.content = mParser.csv_dict_reader(ADEX_file, self.heads)
        self.child_id = self.get_ChildID()
        self.start_time  = self.get_start_time()

    def remove_30mins(self):
        final_start = 0
        counter = 0
        index = self.heads.index('Audio_Duration')

        # remove first 1800 sec at the beginning
        for row in self.content:
            value = float(row[index])
            counter += value
            final_start += 1
            if counter >= 1800:
                break

        lg.debug("removing 5 minutes...")
        self.content = self.content[final_start:]

    def remove_last2rows(self):
        final_end = len(self.content) - 2
        if final_end > 0:
            self.content = self.content[:final_end]

    # find any time duration not up to the time interval
    # remove 1 row before and 1 row after
    def remove_partial_time(self, interval_sec):
        index = self.heads.index('Audio_Duration')
        clock_index = self.heads.index('Clock_Time_TZAdj')
        start_time = 0
        end_time = 0

        for row in self.content:
            value = float(row[index])
            if value != interval_sec:
                if start_time == 0:
                    start_time = timestr_to_second(row[clock_index]) - interval_sec
                end_time = timestr_to_second(row[clock_index]) + interval_sec
            else:
                if start_time != 0:
                    self.remove_time(start_time, end_time)
                    start_time = 0

            # for the last row
            if start_time != 0:
                self.remove_time(start_time, end_time)

    def get_ChildID(self):
        index = self.heads.index('Child_ChildID')
        return self.content[0][index].lower()

    def get_ChildAge(self):
        index = self.heads.index('Child_Age')
        return self.content[0][index].lower()

    def get_ChildGender(self):
        index = self.heads.index('Child_Gender')
        return self.content[0][index].lower()

    def get_NumRecording(self):
        index = self.heads.index('Number_Recordings')
        return self.content[0][index].lower()

    def get_start_time(self):
        index = self.heads.index('Clock_Time_TZAdj')
        return timestr_to_second(self.content[0][index])

    def remove_naptime(self, naptime_dict):
        if self.child_id in naptime_dict:
            start_date = time.strftime('%Y%m%d', time.localtime(self.start_time))
            for i in naptime_dict[self.child_id]:
                if i[0] == start_date:
                    self.remove_time(self.start_time + i[1],
                                     self.start_time + i[2])

    def remove_time(self, start_time, end_time):
        lg.debug("removing naptime...")
        time_start = 0
        time_end = len(self.content)
        count = 0
        index = self.heads.index('Clock_Time_TZAdj')

        for row in self.content:
            cur_time = timestr_to_second(row[index])

            if (cur_time >= start_time) and (time_start == 0):
                time_start = count
            if (cur_time > end_time) and (time_end == len(self.content)):
                time_end = count

            count += 1

        del self.content[time_start : time_end]

    def save_DB(self, DB):
        sql = ""

        # check the existence of childID
        if DB.select('sqlite_master', ['name'],
                     where="type='table' AND name='"+self.child_id +"'") is None:

            lg.debug(self.child_id + " is not in database")
            param = [i + ' ' + HEAD_TYPE_DICT[i] for i in self.heads]
            param.insert(0, "ID INTEGER PRIMARY KEY AUTOINCREMENT")
            param = ",".join(param)
            sql = "CREATE TABLE " + self.child_id + "(" + param + ")"
            DB.execute_script(sql)

        # insert content into DB
        DB.insert_table(self.child_id, self.heads, self.content)

# for test
# init_debug()
# ADEX_proc = ADEXProcessor()
# ADEX_proc.run(["/tmp/test/data/"])
